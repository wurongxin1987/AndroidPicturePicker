apply plugin: 'com.android.application'

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.3"

    defaultConfig {
        applicationId "io.valuesfeng.demo"
        minSdkVersion 11
        targetSdkVersion 23
        versionCode 1
        versionName "1.0"
    }

    signingConfigs {
        myConfig {
            storeFile file("key.jks")
            storePassword "123123"
            keyAlias "simple"
            keyPassword "123123"
        }
    }

    buildTypes {
        release {
            signingConfig signingConfigs.myConfig
            minifyEnabled false
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }
    }
    repositories {
        flatDir {
            dirs 'libs' //this way we can find the .aar file in libs folder
        }
    }


}

dependencies {
    compile fileTree(include: ['*.jar'], dir: 'libs')
    compile 'com.android.support:appcompat-v7:23.1.1'
    compile 'com.nostra13.universalimageloader:universal-image-loader:1.9.3'
    compile 'com.github.bumptech.glide:glide:3.6.1'
    compile 'com.squareup.picasso:picasso:2.5.2'
//    compile(name: 'gallery-release', ext: 'aar')
    compile project(':gallery')
}

afterEvaluate {
    android.applicationVariants.each { variant ->
        def dx = tasks.findByName("transformClassesWithDexFor${variant.name.capitalize()}")
        def assembleTask = tasks.findByName("assemble${variant.name.capitalize()}");
        def instrumentationTask = "instrumentClasses${variant.name.capitalize()}"
        def postInstrumentationTask = "afterInstrumentClasses${variant.name.capitalize()}"
        def backupJavaByteCodePath = "${buildDir}${File.separator}intermediates${File.separator}backupclasses${variant.name.capitalize()}"
        def instrumenterFilePath = "$projectDir${File.separator}..${File.separator}full.jar"
        def javaByteCodePath = "${buildDir}${File.separator}intermediates${File.separator}classes${File.separator}${variant.name}"
//        def rtJarPath = System.getenv("JAVA_HOME") + File.separator + "bin" + File.separator + "jre" + File.separator + "lib" + File.separator + "rt.jar"
//        def androidSDKJarPath = System.getenv("ANDROID_HOME") + File.separator + "platforms" + File.separator + "android-" + android.compileSdkVersion + File.separator + "android.jar"
//        def androidSDKJarPath = "${buildDir}${File.separator}android.jar"
        def instrumentedClassesPath = "${buildDir}${File.separator}instrumentedClasses${variant.name.capitalize()}"
        def sootClassPathSeparator = ":"
        if (org.apache.tools.ant.taskdefs.condition.Os.isFamily(org.apache.tools.ant.taskdefs.condition.Os.FAMILY_WINDOWS)) {
            sootClassPathSeparator = ";"
        }
        def verbose = true
        def sootClassPath = ""
        configurations.compile.each {
            sootClassPath += "\""+it.getAbsolutePath() + "\"" + sootClassPathSeparator
        }
        if(sootClassPath.endsWith(sootClassPathSeparator)){
            sootClassPath = sootClassPath.substring(0, sootClassPath.length() - 1)
        }
//        sootClassPath = androidSDKJarPath + sootClassPathSeparator + sootClassPath
        println "soot class path:"+sootClassPath

//        println "project information:" + project.getDependencies().project()
//        println "project information:" + project.getRootProject().getChildProjects().size()

        if (dx != null && verbose) {
            task(instrumentationTask) << {
                println "instrumenting classes"
                /*back up the classes in the format of java bytecode*/
                println "begin to back up the classes in the format of java bytecode"
                new File(backupJavaByteCodePath).mkdirs()
                new groovy.util.AntBuilder().copy(todir: backupJavaByteCodePath) {
                    fileset(dir: javaByteCodePath)
                }

                /*instrument java bytecode classes*/
//                def cmd = "java -Xmx1024m -jar $instrumenterFilePath --soot-classpath \"$rtJarPath\"$sootClassPathSeparator\"$androidSDKJarPath\" --process-dir $javaByteCodePath -d $instrumentedClassesPath"
                def cmd = "java -Xmx1024m -jar $instrumenterFilePath --soot-classpath $sootClassPath --process-dir $javaByteCodePath -d $instrumentedClassesPath"
                println "begin to instrument the java bytecode classes"
                println "the command for instrumentation is:"
                println cmd
                exec {
                    commandLine cmd.split().toList()
                }

                /*copy the instrument the instrumented classes to replace the original classes*/
                println "begin to replace the original class with the instrumented classes"
                new groovy.util.AntBuilder().copy(todir: javaByteCodePath, overwrite:true) {
                    fileset(dir: instrumentedClassesPath)
                }
            }


            task(postInstrumentationTask) << {
                println "after instrumenting classes"

                /*specially delte the directory*/
                (new File(javaByteCodePath + File.separator + "casper")).deleteDir()

                /* after package into dex code, we recovered the original java bytecode*/
                println "begin to replace the instrumented class with the original classes after dex code generation"
                new groovy.util.AntBuilder().copy(todir: javaByteCodePath, overwrite:true) {
                    fileset(dir: backupJavaByteCodePath)
                }
                /* delete the back up directories that stores original classes*/
                println "delete the back up directories " + backupJavaByteCodePath
                (new File(backupJavaByteCodePath)).deleteDir()
            }

            /*build the dependencies for instrumentationTask*/
            tasks.findByName(instrumentationTask).dependsOn dx.taskDependencies.getDependencies(dx)
            dx.dependsOn tasks.findByName(instrumentationTask)

            /*build the dependencies for postInstrumentationTask*/
            tasks.findByName(postInstrumentationTask).dependsOn assembleTask.taskDependencies.getDependencies(assembleTask)
            assembleTask.dependsOn tasks.findByName(postInstrumentationTask)
//            tasks.findByName(postInstrumentationTask).dependsOn dx.taskDependencies.getDependencies(dx)
//            tasks.findByName(postInstrumentationTask).dependsOn dx
//            tasks.findByName(postInstrumentationTask).mustRunAfter dx
        }
    }
}